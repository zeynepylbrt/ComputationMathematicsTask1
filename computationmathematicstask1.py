# -*- coding: utf-8 -*-
"""ComputationMathematicsTask1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15seof4HQBBO82OVwjEChCSz4MNV70Z6W
"""

'''Authors
On behalf of TU Dresden
Anushka Pankaj Joshi
Kleio Liotati
Zeynep Yilbirt'''

# numpy for basic array calculations
import numpy as np
import matplotlib as plt
import matplotlib.pyplot as plt
from matplotlib import rcParams
# Set the font to DejaVu Sans, which is available in your list
rcParams['font.family'] = 'sans-serif'
rcParams['font.sans-serif'] = ['DejaVu Sans']

#include latex rendering in plots
plt.rcParams.update({
"text.usetex": True,
"font.family": "serif",
"font.serif": ["Computer Modern Roman"],
})

import numpy as np
import matplotlib.pyplot as plt
# Set the font to DejaVu Sans, which is available in your list
rcParams['font.family'] = 'sans-serif'
rcParams['font.sans-serif'] = ['DejaVu Sans']


# Disable LaTeX rendering
plt.rcParams['text.usetex'] = False

# Define the probability distribution
values = np.linspace(-3,3,251) # k+1 values b/w -3 and 3 in an array
probabilities = np.exp(-(values)**2) #Gaussian not normalised
probabilities /=np.sum(probabilities) #normalised propabilities

# Construct the histogram
# -> produce N='size' randomm values according probability distribution defined by
# values and probabilities
np.random.seed(69)
hist_values = np.random.choice(values, size=1000, p=probabilities)
print(min(hist_values),max(hist_values))
myBins=values.tolist()
dVal=values[1]-values[0]
myBins.append(values[-1]+values[1]-values[0])
myBins=np.array(myBins)-dVal/2
# Plot the histogram
plt.hist(hist_values, bins=myBins, density=True, alpha=0.75)
plt.plot(values,probabilities/dVal)
plt.xlabel('Values')
plt.ylabel('Probability')
plt.title('Probability Distribution Histogram: $P(x) = e^{-x^2}$')
plt.grid(True)
plt.show()

# Calculate the mean
mean = np.sum(values * probabilities)
print(mean)

#seed
DL=100
N=2
dl=DL/N
x=np.array([i*dl for i in range(N)])+0.5*dl
y=np.array([i*dl for i in range(N)])+0.5*dl
xx,yy = np.meshgrid(x,y)
xx=xx.flatten()
yy=yy.flatten()

# periodic BC

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm

# Define parameters
v = 1  # velocity
dt = 1  # timestep
Nmax = 1e4  # Number of timesteps
angles = [20, 18, 16, 14, 12, 10, 8, 6, 4]   # List of angle values


# Function to handle boundary wrapping using modulo
def wrap_position(xn, yn, DL):
    xn %= DL
    yn %= DL
    return xn, yn

# List to store Nmax values for each angle
all_Nmax_values = {angle: [] for angle in angles}

# Open a file to write the data
with open('particle_data.txt', 'w') as file:
    for sim in range(1, 251):  # Run the simulation k-1 times
        file.write(f"\nSimulation {sim}\n")
        # Loop over angle values
        for angle in angles:
            print(f"Angle: {angle}")

            # Initialize particle data
            ParticleData = []
            Theta0 = np.random.rand(len(xx)) * 2 * np.pi  # initial orientation

            # Generate a unique color for each particle
            colors = cm.jet(np.linspace(0, 1, len(xx)))

            # Loop over all particles
            for x0, y0, theta0, n, color in zip(xx, yy, Theta0, range(len(xx)), colors):
                pard = []  # list to store particle path
                pard.append(np.array([x0, y0, theta0]))  # first position of particle
                xn = x0
                yn = y0
                thetan = theta0
                time = [0]

                # Loop for every timestep
                for i in range(int(Nmax)):
                    # Propagate particle
                    xn_new = xn + v * np.cos(thetan) * dt
                    yn_new = yn + v * np.sin(thetan) * dt

                    # Check if particle crossed the circle
                    if (xn_new - DL / 2) ** 2 + (yn_new - DL / 2) ** 2 <= (DL * 0.2) ** 2:
                        all_Nmax_values[angle].append(i)
                        print("Particle crossed the circle at time:", time[-1])
                        break  # Stop propagation

                    # Check for boundary crossing and wrap position using modulo
                    crossed_boundary = xn_new < 0 or xn_new > DL or yn_new < 0 or yn_new > DL
                    xn_wrapped, yn_wrapped = wrap_position(xn_new, yn_new, DL)

                    # Change direction of particle according to our self-defined distribution
                    Dtheta = np.random.choice(values, p=probabilities) * 2 * np.pi / angle
                    thetan = thetan + Dtheta

                    # Collect results
                    if crossed_boundary:
                        time.append(time[-1] + dt / 2)  # Time before wrapping
                        pard.append(np.array([xn_new, yn_new, thetan]))  # Record point before wrapping
                        time.append(time[-1] + dt / 2)  # Time after wrapping
                        pard.append(np.array([xn_wrapped, yn_wrapped, thetan]))  # Record wrapped point
                    else:
                        time.append(time[-1] + dt)
                        pard.append(np.array([xn_wrapped, yn_wrapped, thetan]))

                    xn, yn = xn_wrapped, yn_wrapped  # Update particle position

                # Store particle path of n-th particle
                ParticleData.append(np.array(pard).transpose())
                print('Part Nr : ' + str(n) + ' tmax ' + str(np.array(time)[-1]))

                # Write data to file
                for t, (x, y, theta) in zip(time, pard):
                    file.write(f"{angle} {sim} {t} {n} {theta} {dt} {x} {y}\n")

            # Plot particle paths
            for path, color in zip(ParticleData, colors):
                # Plot segments without boundary crossing
                for i in range(1, path.shape[1]):
                    x_prev, y_prev = path[0, i-1], path[1, i-1]
                    x_curr, y_curr = path[0, i], path[1, i]
                    if not (abs(x_curr - x_prev) > DL / 2 or abs(y_curr - y_prev) > DL / 2):
                        plt.plot([x_prev, x_curr], [y_prev, y_curr], '-', color=color)
                    else:
                        # Plot circles at the boundary crossing points
                        plt.gca().add_patch(plt.Circle((x_prev, y_prev), 1, color=color, fill=True))
                        plt.gca().add_patch(plt.Circle((x_curr, y_curr), 1, color=color, fill=True))

            # Plot the circle
            circle = plt.Circle((DL / 2, DL / 2), DL * 0.2, color='red', alpha=0.5)
            plt.gca().add_patch(circle)

            # Draw the boundary
            boundary = plt.Rectangle((0, 0), DL, DL, fill=False, edgecolor='black')
            plt.gca().add_patch(boundary)

            # Add labels and title
            plt.xlabel('X')
            plt.ylabel('Y')
            plt.title(f'Particle Paths with Circle (Simulation {sim}, Angle: {angle})')

            # Show the plot
            plt.xlim(0, DL)
            plt.ylim(0, DL)
            plt.gca().set_aspect('equal', adjustable='box')
            plt.show()

        # Reset data_dict for the next simulation round

# Calculate and print average Nmax across all particles and simulations for each angle
for angle, Nmax_values in all_Nmax_values.items():
    if Nmax_values:
        avg_Nmax = np.mean(Nmax_values)
        print(f"Average Nmax for angle {angle} across all particles and simulations: {avg_Nmax}")
    else:
        print(f"No particles reached the target for angle {angle} across all particles and simulations")

# Code for a particle running until Tmax

import numpy as np
import matplotlib.pyplot as plt

# Define parameters
v = 1  # velocity
dt = 1  # timestep
N=1
Nmax = int(1e4)  # Number of timesteps
angles = [20, 18, 16, 14, 12, 10, 8, 6, 4]  # List of angle values
repetitions = 250  # Number of repetitions for each angle
DL = 100  # Assuming a predefined value for DL if needed

'''# Define probabilities and values for direction change
values = np.linspace(-1, 1, 100)  # Example values
probabilities = np.ones(100) / 100  # Example probabilities
'''

# Define the probability distribution
#values = np.linspace(-3,3,501)
#probabilities = np.exp(-(values)**2) #Gaussian not normesd
#probabilities /=np.sum(probabilities) #norm probabilities

# Example particle positions and orientations (placeholders)
xx = np.random.rand(N) * DL
yy = np.random.rand(N) * DL

# Open a file to write the data
with open('particle_data.txt', 'w') as file:
    # Loop over angle values
    for angle in angles:
        print(f"Angle: {angle}")
        # Loop over repetitions
        for rep in range(repetitions):
            print(f"Repetition: {rep + 1}")

            # Initialize particle data
            ParticleData = []
            Theta0 = np.random.rand(len(xx)) * 2 * np.pi  # initial orientation

            # Vectorized initialization of particle data
            xn = np.tile(xx, (Nmax, 1)).T
            yn = np.tile(yy, (Nmax, 1)).T
            thetan = np.tile(Theta0, (Nmax, 1)).T

            time = np.arange(0, Nmax * dt, dt)

            # Vectorized particle propagation
            for t in range(1, Nmax):
                xn[:, t] = xn[:, t-1] + v * np.cos(thetan[:, t-1]) * dt
                yn[:, t] = yn[:, t-1] + v * np.sin(thetan[:, t-1]) * dt
                Dtheta = np.random.choice(values, size=len(xx), p=probabilities) * 2 * np.pi / angle
                thetan[:, t] = thetan[:, t-1] + Dtheta

            for n in range(len(xx)):
                pard = np.vstack((xn[n], yn[n], thetan[n]))
                ParticleData.append(pard)

                # Write data to file
                for t in range(Nmax):
                    file.write(f"{angle} {rep + 1} {time[t]} {n} {thetan[n, t]} {dt} {xn[n, t]} {yn[n, t]}\n")

            # Plot particle paths
            for path in ParticleData:
                plt.plot(path[0], path[1], '-')

            # Add labels and title
            plt.xlabel('X')
            plt.ylabel('Y')
            plt.title(f'Particle Paths (Angle: {angle}, Repetition: {rep + 1})')

            # Show the plot
            plt.show()

# cat particle_data.txt
# Step 1: Open the file
file_path = 'particle_data.txt'
num_lines_to_read = 100
try:
    with open(file_path, 'r') as file:
        # Step 2: Read the file
        for i in range(num_lines_to_read):
            line = file.readline()
            if not line:
                break  # Stop if the end of the file is reached before 100 lines
            print(line, end='')  # Use end='' to avoid adding extra newlines

        # Step 3: Print the contents
except FileNotFoundError:
    print(f"The file {file_path} does not exist.")
except IOError:
    print(f"An error occurred while reading the file {file_path}.")



# MSD code

import numpy as np
import matplotlib.pyplot as plt

# Load particle data from file
ParticleData = []
with open('particle_data.txt', 'r') as file:
    for line in file:
        angle, rep, time, n, theta, dt, x, y = map(float, line.strip().split())
        ParticleData.append((angle, rep, time, n, theta, dt, x, y))

ParticleData = np.array(ParticleData)

# Define the calculate_msd function
def calculate_msd(particle_data):
    x = particle_data[:, 6]  # x-coordinate data
    y = particle_data[:, 7]  # y-coordinate data
    time = particle_data[:, 2]  # time data
    N = len(x)
    msd = []
    for di in range(1, N-1):
        tau = time[di] - time[0]  # Calculate tau
        if tau == 0:
            continue
        x0 = x[:-di]
        x1 = x[di:]
        y0 = y[:-di]
        y1 = y[di:]
        dx = (x0 - x1) ** 2
        dy = (y0 - y1) ** 2
        msd.append(dx.mean() + dy.mean())
    return np.array(msd)

# Initialize angles and repetitions (example values, replace with actual data if needed)
angles = np.unique(ParticleData[:, 0])
repetitions = int(np.max(ParticleData[:, 1]))

# Calculate MSD for all particles
msd_all_angles = {}
msd_reps_all = {}
msd_std_all_angles = {}  # Store standard deviations

for angle in angles:
    msd_reps = []
    for rep in range(1, repetitions + 1):
        particle_data_angle_rep = ParticleData[(ParticleData[:, 0] == angle) & (ParticleData[:, 1] == rep)]
        if particle_data_angle_rep.size == 0:
            continue
        msd = calculate_msd(particle_data_angle_rep)
        msd_reps.append(msd)

    if not msd_reps:
        continue

    # Truncate MSD arrays to the length of the shortest array
    min_length = min(len(msd) for msd in msd_reps)
    truncated_msd_reps = [msd[:min_length] for msd in msd_reps]

    # Store individual repetitions
    msd_reps_all[angle] = truncated_msd_reps

    # Calculate the mean and standard deviation MSD
    msd_mean = np.mean(truncated_msd_reps, axis=0)
    msd_std = np.std(truncated_msd_reps, axis=0)

    msd_all_angles[angle] = msd_mean
    msd_std_all_angles[angle] = msd_std

# Plot MSD for each angle separately with repetitions
for angle in msd_all_angles:
    plt.figure(figsize=(10, 6))

    # Plot MSD for each repetition in different colors
    for rep_msd in msd_reps_all[angle]:
        plt.plot(rep_msd, alpha=0.5)  # Alpha for transparency

    # Plot the average MSD in a bold line
    plt.plot(msd_all_angles[angle], label=f"Angle: {angle}", linewidth=2, color='black')

    plt.xlabel('Time lag')
    plt.ylabel('Mean square displacement')
    plt.title(f'Mean Square Displacement for Particles (Angle: {angle})')
    plt.xscale('log')
    plt.yscale('log')
    plt.legend()
    plt.grid(True, which="major", ls="--")
    plt.show()

    # Print the MSD values
    print(f"Angle: {angle}")
    print("Time lag, MSD")
    for i, msd_value in enumerate(msd_all_angles[angle][:10]):
        print(f"{i}, {msd_value}")
    print("\n")

# Plot average MSD for all angles in a separate plot
plt.figure(figsize=(12, 8))
for angle, msd_average in msd_all_angles.items():
    plt.plot(msd_average, label=f"Angle: {angle}", linewidth=2)
plt.xlabel('Time lag')
plt.ylabel('Mean square displacement')
plt.title('Mean Square Displacement for Particles with Different Angles')
plt.xscale('log')
plt.yscale('log')
plt.legend()
plt.grid(True, which="major", ls="--")
plt.show()

# Plot standard deviation of MSD for all angles in one plot
plt.figure(figsize=(12, 8))
for angle, msd_std in msd_std_all_angles.items():
    plt.plot(msd_std, label=f"Angle: {angle}", linewidth=2)
plt.xlabel('Time lag')
plt.ylabel('Standard deviation of MSD')
plt.title('Standard Deviation of Mean Square Displacement for Different Angles')
plt.xscale('log')
plt.yscale('log')
plt.legend()
plt.grid(True, which="major", ls="--")
plt.show()

# Code for MSD Slope

import numpy as np
import matplotlib.pyplot as plt

# Function to calculate slope from MSD
def calculate_slope(log_msd, log_time_lags):
    slopes = np.diff(log_msd) / np.diff(log_time_lags)
    return slopes, log_time_lags[1:]

# Initialize lists to store data for all angles
all_slopes = []
all_adjusted_log_time_lags = []

# Calculate and store slope vs. time lag for each angle
for angle, msd_average in msd_all_angles.items():
    time_lags = np.arange(1, len(msd_average) + 1)

    # Convert MSD and time lags to logarithms
    log_msd = np.log(msd_average)
    log_time_lags = np.log(time_lags)

    slopes, adjusted_log_time_lags = calculate_slope(log_msd, log_time_lags)

    # Store slopes and adjusted log time lags
    all_slopes.append(slopes)
    all_adjusted_log_time_lags.append(adjusted_log_time_lags)

    # Print the first few slope values for clarity
    print(f"Angle: {angle}")
    print("Time lag, Slope")
    for i, slope_value in enumerate(slopes[:10]):  # Print the first 10 slopes
        print(f"{i+1}, {slope_value}")
    print("\n")

# Plot all slopes vs. time lag on the same plot
plt.figure(figsize=(10, 6))
for angle, slopes, adjusted_log_time_lags in zip(msd_all_angles.keys(), all_slopes, all_adjusted_log_time_lags):
    plt.plot(np.exp(adjusted_log_time_lags[:8000]), slopes[:8000], label=f"Angle: {angle}")

plt.xlabel('Time lag')
plt.ylabel('Slope')
plt.title('Slope vs. Time Lag for Particles')
plt.xscale('log')
plt.yscale('linear')
plt.grid(True, which="major", ls="--")
plt.legend()
plt.show()

